\subsubsection{Motivation and overview}
\label{motivation-and-overview}

The rules defined above are already quite expressive. However, they aren't
enough to type the following function, no matter how the type annotations are
written:

\begin{lstlisting}[language=NLight]
  (lambda cond. lambda x.  (y := cond in true) ? x+1 : not x
  : (true -> Int -> Int & false -> Bool -> Bool))
\end{lstlisting}

Indeed, do to this we would need to annotate $x$ as \ty{Int} or \ty{Bool}
depending on wether \texttt{cond} was \ty{true} or \ty{false}, which isn't
possible.

To remedy this problem, we split our type system in two parts: an inference
part and a checking part.  The inference part − denoted with typing judgements
of the form $\Γ \tinfer e : \τ$ − corresponds to classical bottom-up
type-inference, while the checking part − denoted with typing judgements of the
form $\Γ \tcheck e : \τ$ corresponds to a top-down type inference, where the
type of the expression is already known and we use it to infer the type of the
sub-expressions − in other words, we propagate the type annotations to the
bottom while type-checking. In particular, this ``checking'' type-system allows
us a more precise typing of lambdas.

Explicitly annotated let-bindings are thus typed using the checking type-system
and we can rewrite the previous expression as
\begin{lstlisting}[language=NLight]
let f : (true -> Int -> Int & false -> Bool -> Bool) =
 lambda cond. lambda x.  (y := cond tin true) ? x+1 : not x
in f
\end{lstlisting}

In this case, we just have to \emph{check} that
\begin{lstlisting}[language=NLight]
lambda x. (y := cond tin true) ? x+1 : not x
\end{lstlisting}
has type $\ty{Int} \rightarrow \ty{Int}$ under the hypothesis $\texttt{cond} :
\ty{true}$ and $\ty{Bool} \rightarrow \ty{Bool}$ under the hypothesis
$\texttt{cond} : \ty{false}$. This means checking that
\begin{lstlisting}[language=NLight]
(y := cond tin true) ? x+1 : not x
\end{lstlisting}
has type $\ty{Int}$ under the hypothesis $\texttt{cond} : \ty{true}; \texttt{x}
: \ty{Int}$ and $\ty{Bool}$ under the hypothesis $\texttt{cond} : \ty{false};
\texttt{x} : Bool$. This is true, thanks to the ruls CTcase of the type system
(figure~\pref{typing::lambda-calculus}).

So the basic idea behind this is to use the type annotations of parent nodes
(or any other type information that we got from upper in the AST), not just to
check that the inferred type was correct, but in the inference process itself.

\subsubsection{Pairs}\todo{Replace by lists}

For example, if we want to type the expression $(e_1, e_2) : (\τ_1 \times
\τ_2)$, we will try to type $(e_1 : \τ_1)$ and $(e_1 : \τ_2)$ and then merge
the results.
In a more general fashion, if we got $(e_1, e_2) : \τ$ − where $\τ$ is any
subtype of $\one \times \one$ − we will need to project $\τ$ on its first and
second component respectively to type $e_1$ and $e_2$.

We thus extends this definition of the projections $\pi_1$ and $\pi_2$ to more
complex pair types (\emph{ie.} subtypes of $\one \times \one$), keeping the
invariant that for a given subtype $\τ$ of $\one \times \one$, $\pi_1(\τ)
\times \pi_2(\τ)$ is a subtype~\todo{Gradual ?} of $\τ$, so that if $e_1$ has
type $\pi_1(\τ)$ and $e_2$ has type $\pi_2(\τ)$, then $(e_1, e_2)$ can be given
the type $\τ$.

Let $\τ$ be a subtype of $\one \times \one$.
We know that $\τ$ can be written as:
\[
  \τ = \bigvee\limits_{i\in I}\left(\bigwedge\limits_{p\in P_i} (\σ_p \times \τ_p)
  \wedge \bigwedge\limits_{n \in N_i} \lnot (\σ_n \times \τ_n) \right)
\]
We define $\pi_1(\τ)$ (resp. $\pi_2(\τ)$) as
\begin{align*}
  \pi_1(\τ) &= \bigwedge\limits_{i \in I} \bigwedge\limits_{N' \subseteq N}
    \left(\bigwedge\limits_{p \in P_i} \σ_p \wedge
    \bigwedge\limits_{n \in N'} \lnot \σ_n \right)\\
  \pi_2(\τ) &= \bigwedge\limits_{i \in I} \bigwedge\limits_{N' \subseteq N}
    \left(\bigwedge\limits_{p \in P_i} \τ_p \wedge
    \bigwedge\limits_{n \in N'} \lnot \τ_n \right)
\end{align*}

We can check\todo{Check that this is indeed true} that this definition respects
our constraint.

\subsubsection{Arrows}

Another construct for which we want to propagate type informations is the
definition of a function.

Assume we got an expression $(\λ p . e) : \τ$ where $\τ$ is a subtype (not
gradual) of $\zero \rightarrow \one$.

We want to type the function for each concrete arrow type included in $\τ$. In
other words, if we note $\A(\τ)$ the set of all arrow types in $\τ$, we want that
for all $\σ \rightarrow \σ' \in \A(\τ)$, $p$ matches $\σ$, and that under this
matching, $e$ has type $\σ'$.

This is given by the rule \emph{CAbs} of the type system in the
Figure~\pref{typing::lambda-calculus}.

Remains the definition of $\A(\τ)$, that we give as follows:

If $\τ$ is in the form
\[
  \τ = \bigvee\limits_{i\in I}\left(
    \bigwedge\limits_{p\in P_i} (\σ_p \rightarrow \τ_p)
    \wedge \bigwedge\limits_{n \in N_i} \lnot (\σ_n \rightarrow \τ_n)
  \right)
\]
then $\A(\τ)$ is given by:
\[
  \A(\τ) = \bigsqcup\limits_{i \in I} \{ \σ_p \rightarrow \τ_p \| p \in P_i \}
\]
where $\sqcup$ is defined as
\[
  \{ \σ_i \rightarrow \τ_i \| i \in I \} \sqcup \{ \σ_j \rightarrow \τ_j \| j \in J \} =
    \{ (\σ_i \wedge \σ_j) \rightarrow (\τ_i \vee \τ_j) \| i \in I, j \in J \}
\]

In the example of the Section~\ref{motivation-and-overview}, the expression has
type $t = (true \rightarrow (Int \rightarrow Int)) \wedge (false \rightarrow
(Bool \rightarrow Bool))$

Thus, we have $\A(t)$ equal to the set $\left\{ true \rightarrow (Int
\rightarrow Int); false \rightarrow (Bool \rightarrow Bool) \right\}$
