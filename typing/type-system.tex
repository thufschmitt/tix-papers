\subsection{The $\λ\&-calculus$}

\subsubsection{Patterns}

In order to type patterns, we need to introduce a new form of typing judgement.
The judgement $\Γ \dashv p:\τ$ means that when applied against a type $\τ$, the
pattern $p$ will enrich the environment with the constraints $\Γ$.

For example, we got $x:\Int \dashv x:\Int$, which reads ``If we apply a term
of type $\Int$ to the pattern $x$, then the environment on the
right of the pattern will be enriched with the constraint $x:\Int$''

Likewise, the following statement holds.
\[x:\Int; y: \Bool \dashv \left\{ x; y ? \text{true}; \right\} : \{ x = \Int; y =? \Bool \}\]
This means that when if we match a term of type $\left\{ x =\Int; y =? \Bool
\right\}$ against the pattern $\left\{ x; y ? \text{true}; \right\}$, then the
environment on the right side of the pattern will be enriched with the
constraints $x : \Int$ and $y : \Bool$.

As the symbol ``$\dashv$'' suggests, this typing judgement is the converse of
the classical typing judgement $\Γ \vdash e : \τ$ for expressions: instead of
stating that under the hypothesis $\Γ$, the expression $e$ has type $\τ$, we
state that if the pattern $p$ has type $\τ$, then in produces the environment
$\Γ$.

The typing rules for this statement are given by the
figure~\pref{typing::patterns::typing-rules}.

Maybe~\todo{Find out wether this is true} this enjoys principal typing.

\subsubsection{Typecase}

The typecase $(x := e \in t) ? e_1 : e_2$ can be typed in a simple way, by
saying that if $e$ has a type $τ$, $e_1$ has type $\τ_1$ and $e_2$ has type
$\τ_2$ (under the current typing environment $\Γ$), then $(x := e \in t) ? e_1
: e_2$ has type $\τ_1 \vee \τ_2$.
However, doing so means that we do not use the extra type information given by
``$e \in t$'', which loosens a lot the interest of this construct. For example,
an expression such as $(x := e \in \bm{{Int}}) ? x + 1 : x$, with $\vdash e :
\any$ wouldn't typecheck, as $x+1$ isn't well typed without any further
constraint on the type of $x$.

A more interesting typing rule would state that if $\Γ; x:\τ \wedge t \vdash
e_1: \τ_1$ and $\Γ; x:\τ \wedge \lnot t \vdash e_2: \τ_2$ (where $\τ$ is a type
of $e$ under the hypothesis $\Γ$), then the whole expression has type $\τ_1
\vee \τ_2$.
With this rule, the expression $(x := e \in \bm{{Int}}) ? x + 1 : x$ is
well-typed (provided that $e$ is).

The typing rules are given by the
figures~\pref{typing::lambda-calculus},~\pref{typing::records}
and~\pref{typing::operators}.

\subsection{Bidirectional typing}

\subsubsection{Motivation and overview}

The rules defined above are already quite expressive. However, they aren't
enough to type the following function, no matter how the type annotations are
written:

\begin{lstlisting}[language=NLight]
  (lambda cond. lambda x.  (y = cond in true) ? x+1 : not x
  : (true -> Int -> Int & false -> Bool -> Bool))
\end{lstlisting}

Indeed, do to this we would need to annotate $x$ as \ty{Int} or \ty{Bool}
depending on wether \texttt{cond} was \ty{true} or \ty{false}, which isn't
possible.

To remedy this problem, we split our type system in two parts: an inference
part and a checking part.  The inference part − denoted with typing judgements
of the form $\Γ \tinfer e : \τ$ − corresponds to classical bottom-up
type-inference, while the checking part − denoted with typing judgements of the
form $\Γ \tcheck e : \τ$ corresponds to a top-down type inference, where the
type of the expression is already known and we use it to infer the type of the
sub-expressions − in other words, we propagate the type annotations to the
bottom while type-checking. In particular, this ``checking'' type-system allows
us a more precise typing of lambdas.

Explicitly annotated let-bindings are thus typed using the checking type-system
and we can rewrite the previous expression as
\begin{lstlisting}[language=NLight]
let f : (true -> Int -> Int & false -> Bool -> Bool) =
 lambda cond. lambda x.  (y = cond tin true) ? x+1 : not x
in f
\end{lstlisting}

In this case, we just have to \emph{check} that
\begin{lstlisting}[language=NLight]
lambda x. (y = cond tin true) ? x+1 : not x
\end{lstlisting}
has type $\ty{Int} \rightarrow \ty{Int}$ under the hypothesis $\texttt{cond} :
\ty{true}$ and $\ty{Bool} \rightarrow \ty{Bool}$ under the hypothesis
$\texttt{cond} : \ty{false}$. This means checking that
\begin{lstlisting}[language=NLight]
(y = cond tin true) ? x+1 : not x
\end{lstlisting}
has type $\ty{Int}$ under the hypothesis $\texttt{cond} : \ty{true}; \texttt{x}
: \ty{Int}$ and $\ty{Bool}$ under the hypothesis $\texttt{cond} : \ty{false};
\texttt{x} : Bool$. This is true, thanks to the rules TcaseL and TcaseR of the
type system (figure~\pref{typing::lambda-calculus}).

\subsubsection{Description of the top-down type-checking}
\label{sec::lambda::topDown::descr}

The basic idea behind the top-down type-checking is to use the type annotations
of parent nodes (or any other type information that we got from upper in the
AST), not just to check that the inferred type was correct, but in the
inference process itself.

For example, if we want to type the expression $(e_1, e_2) : (\τ_1 \times
\τ_2)$, we will try to type $(e_1 : \τ_1)$ and $(e_1 : \τ_2)$ and then merge
the results.
In a more general fashion, if we got $(e_1, e_2) : \τ$ − where $\τ$ is any
subtype of $\one \times \one$ − we will need to project $\τ$ on its first and
second component respectively to type $e_1$ and $e_2$. The exact definition of
those projections are defined in Section~\ref{sec::lambda::projections}.

\subsection{Projections of types}
\label{sec::lambda::projections}

\subsubsection{Pairs}

In order to propagate the type informations, we sometimes have to project a
type build from a type constructor onto its different components. For example,
in Section~\ref{sec::lambda::topDown::descr}, we quickly discussed about the
projections of a pair.

We now extends this simple definition of the projections $\pi_1$
and $\pi_2$ to more complex pair types (\emph{ie.} subtypes of $\one \times
\one$), keeping the invariant that for a given subtype $\τ$ of $\one \times
\one$, $\pi_1(\τ) \times \pi_2(\τ)$ is a subtype~\todo{Gradual ?} of $\τ$, so
that if $e_1$ has type $\pi_1(\τ)$ and $e_2$ has type $\pi_2(\τ)$, then $(e_1,
e_2)$ can be given the type $\τ$.

Let $\τ$ be a subtype of $\one \times \one$.
We know that $\τ$ can be written as:
\[
  \τ = \bigvee\limits_{i\in I}\left(\bigwedge\limits_{p\in P_i} (\σ_p \times \τ_p)
  \wedge \bigwedge\limits_{n \in N_i} \lnot (\σ_n \times \τ_n) \right)
\]
We define $\pi_1(\τ)$ (resp. $\pi_2(\τ)$) as
\begin{align*}
  \pi_1(\τ) &= \bigwedge\limits_{i \in I} \bigwedge\limits_{N' \subseteq N}
    \left(\bigwedge\limits_{p \in P_i} \σ_p \wedge
    \bigwedge\limits_{n \in N'} \lnot \σ_n \right)\\
  \pi_2(\τ) &= \bigwedge\limits_{i \in I} \bigwedge\limits_{N' \subseteq N}
    \left(\bigwedge\limits_{p \in P_i} \τ_p \wedge
    \bigwedge\limits_{n \in N'} \lnot \τ_n \right)
\end{align*}

We can check\todo{Check that this is indeed true} that this definition respects
our constraint.

\subsubsection{Arrows}

Another construct for which we want to propagate type informations is the
definition of a function.

Assume we got an expression $(\λ p . e) : \τ$ where $\τ$ is a subtype (not
gradual) of $\zero \rightarrow \one$.

We want to type the function for each concrete arrow type included in $\τ$. In
other words, if we note $\A(\τ)$ the set of all arrow types in $\τ$, we want that
for all $\σ \rightarrow \σ' \in \A(\τ)$, $p$ matches $\σ$, and that under this
matching, $e$ has type $\σ'$.

This is given by the rule \emph{CAbs} of the type system in the
Figure~\pref{typing::lambda-calculus}.

Remains the definition of $\A(\τ)$, that we give as follows:

If $\τ$ is in the form
\[
  \τ = \bigvee\limits_{i\in I}\left(
    \bigwedge\limits_{p\in P_i} (\σ_p \rightarrow \τ_p)
    \wedge \bigwedge\limits_{n \in N_i} \lnot (\σ_n \rightarrow \τ_n)
  \right)
\]
then $\A(\τ)$ is given by:
\[
  \A(\σ) = \bigsqcap\limits_{i \in I} \{ \σ_p \rightarrow \τ_p \| p \in P_i \}
\]
where $\sqcap$ is defined as
\[
  \{ \σ_i \rightarrow \τ_i \| i \in I \} \sqcap \{ \σ_j \rightarrow \τ_j \| j \in J \} =
    \{ (\σ_i \wedge \σ_j) \rightarrow (\τ_i \vee \τ_j) \| i \in I, j \in J \}
\]

\begin{figure}
  \begin{mathpar}
    \inferrule{~}{x:\τ \dashv x:\τ}
    \and\inferrule{~}{\dashv \text{nil} : \text{nil}}
    \and\inferrule{\Γ \dashv p:\τ}{\Γ \dashv (p:\τ):\τ}
    \and\inferrule{%
      \Γ \dashv p : \τ \\ \Bt(c) \subtype \τ
    }{%
      \Γ \dashv p ? c : \τ
    }
    \and\inferrule{%
      \forall i \in \discrete{1}{n}, \Γ_i \dashv r_i : \τ_i \\
      \forall i, j \in \discrete{1}{n}, \text{Vars}(\Γ_i) \cap \text{Vars}(\Γ_j) = \varnothing \\
      \forall i, j \in \discrete{1}{n}, x_i \neq x_j
    }{%
      \Γ_1; \cdots; \Γ_n \dashv \left\{ x_1 = r_1; \cdots; x_n = r_n; \right\}
        : \left\{ x_1 = \τ_1; \cdots; x_n = \τ_n; \right\}
    }
    \and\inferrule{%
      \forall i \in \discrete{1}{n}, \Γ_i \dashv r_i : \τ_i \\
      \forall i, j \in \discrete{1}{n}, \text{Vars}(\Γ_i) \cap \text{Vars}(\Γ_j) = \varnothing \\
      \forall i, j \in \discrete{1}{n}, x_i \neq x_j
    }{%
      \Γ_1; \cdots; \Γ_n \dashv \left\{ x_1 = r_1; \cdots; x_n = r_n; \ldots \right\}
        : \left\{ x_1 = \τ_1; \cdots; x_n = \τ_n; \ldots \right\}
    }
    \and\inferrule{%
      \Γ_1 \dashv p_1 : \τ_1 \\
      \Γ_2 \dashv p_2 : \τ_2 \\
      \text{Vars}(\Γ_1) \cap \text{Vars}(\Γ_2) = \varnothing
    }{%
      \Γ_1; \Γ_2 \dashv \text{Cons}(p_1, p_2) : \text{Cons}(\τ_1, \τ_2)
    }
    \and\inferrule{%
      \Γ \dashv p : \τ \\
      x \notin \Γ
    }{%
      \Γ; x:\τ \dashv p@x : \τ
    }
  \end{mathpar}
  \caption{Typing rules for the patterns\label{typing::patterns::typing-rules}}
\end{figure}

\begin{figure}
  \input{typing/lambdaCalculus}
  \caption{Typing rules for the $\λ\&-calculus$\label{typing::lambda-calculus}\\
  \small{The ``$\delta$'' symbol means either ``$\Uparrow$'' either ``$\Downarrow$''
  (but always the same within a given inferrence rule)}}
\end{figure}
\begin{figure}
    \input{typing/recordTypingRules}
  \caption{Typing rules for records\label{typing::records}}
\end{figure}

\begin{figure}
  \todo{add rules for operators}
  \caption{Typing rules for builtins operators\label{typing::operators}}
\end{figure}
