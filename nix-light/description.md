#### Grammar

This language is really similar to Nix, but makes syntactically distinct all
the elements which requires a special treatment from the typechecker.

For example, the if construct is replaced by the more general "typecase" of the
form `(x = e0 tin t) ? e1 : e2` (which evaluates to `e1` if `e0` evaluates to a
value of type `t` and to `e2` otherwise).
The general case `if e0 then e1 else e2` will be compiled to `(x = (e0 : Bool)
tin true) ? e1 : e2` (where `x` is a fresh variable), whereas particular cases
such as `if isInt x then e1 else e2` may be compiled to spcialized versions
such as `(x = x tin Int) ? e1 : e2`.
This lightens the type-system as both forms can be treated with the same rule.
However, this loosens a little bit the expressivity, as an expression such as
`let f = isInt in if f x then x else 1` won't be recognized by the compiler
(because it has no type information, so can't see that `f` is the same
predicate over types as `isInt` and thus should be treated the same way.

Nix-light's grammar is given in figure \pref{nix-light::grammar}.
The construct `<$\hat{t}$>` (defining the types that appears in a typecase) is
the same as `<t>`, except that the only arrow type that may appear in it is the
type `Empty -> Any`.
The `<>` operator defines the concatenation of records.
In what follows, we assume that this operator is commutative. As consequence,
we allow ourselves to reorder at will the terms of an expression of the form
`<e> <> $\cdots$ <> <e>`.
Moreover, we often write `{ x1 = e1; $\cdots$; xn = en }` as a shortcut for
`{ x1 = e1 } <> $\cdots$ <> { xn = en }`.

\begin{figure}
  \begin{lstlisting}
    <e> ::=
        <x> | <c>
      | <e>.<a> | <e>.<a> or <e>
      | $\lambda$<p>.<e> | <e> <e>
      | let <vr> = <e>; $\cdots{}$; <vr> = <e>; in <e>
      | Cons (<e>, <e>)
      | { <x> = <e> } | {} | <e> <> ... <> <e>
      | (<x> = <e> $\in$ <$\hat{t}$>) ? <e> : <e>
      | <e>:<τ>

    <c> ::= <s> | <i> | <b> | Nil

    <p> ::= <rp> | <rp>@<x> | <vr>

    <rp> ::= <rp>:τ
      | { <rpf>, $\cdots$, <rpf> }
      | { <rpf>, $\cdots$, <rpf>, … }

    <rpf> ::= <vr> | <vr> ? <c>

    <vr> ::= <x> | <x>:<τ>

    <basetype> ::= Bool | Int | String | Any | Empty | Nil

    <t> ::= <c> | <t> $\rightarrow$ <t>
      | <t> $\vee$ <t> | <t> $\wedge$ <t> | $\lnot$ <t>
      | Cons(<t>, <t>) | let <x> = <t>; $\cdots$; <x> = <t> in <t>
      | { <x> = <t>; $\cdots$; <x> = <t>; _ = <t> }
      | <basetype>

    <τ> ::= <c> | <τ> $\rightarrow$ <τ>
      | <τ> $\vee$ <τ> | <τ> $\wedge$ <τ>
      | Cons(<τ>, <τ>) | let <x> = <τ>; $\cdots$; <x> = <τ> in <τ>
      | { <x> = <τ>; $\cdots$; <x> = <τ>; _ = <τ> }
      | <basetype> | ?
      | t
  \end{lstlisting}
  \caption{Grammaire de Nix-light\label{nix-light::grammar}}
\end{figure}

#### Semantic

##### Pattern-matching

The pattern-matching in Nix-light has a rather classical semantic for a lazy
language, with the simplification that as the patterns aren't recursive, the
argument is either non-evaluated at all, either evaluated in head normal form.

\newcommand{\var}{\mathcal{V}}
If `r` is a variable pattern − hence in the forme `x` or `x:τ` where `x` is an
ident and `τ` a type − we define the variable represented by `r` (that we note
$\var(r)$) as $\var(x) = \var(x:\τ) = x$.
In what follows, `l` designs a record-pattern field (of the form `r` or `r?c`
where `c` is a constant).

For a pattern `p` and a value `v` (resp. an expression `e`), we define the
substitution generated by the matching of `v` (resp. `e`) against `p` (noted
$\sfrac{p}{v}$) as follows:

\begin{align*}
  \sfrac{x}{e}    &= x := e \\
  \sfrac{p:\τ}{e}  &= \sfrac{p}{e} \\
  \sfrac{q@x}{v}  &= x := v; \sfrac{q}{v} \\
  \sfrac{\{..\}}{\{\cdots\}} &= \varnothing\\
  \sfrac{\{\}}{\{\}} &= \varnothing \\
  \sfrac{\{ r_1, l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m\}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1, l_1, \cdots, l_m, .. \}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m, .. \}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m\}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m, .. \}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m, .. \}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{c};
       \sfrac{\{ l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
       \text{ if } \forall i \in \{1 .. n\}, x_i \neq \var(r_i) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m, ..\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{c};
       \sfrac{\{ l_1, \cdots, l_m, ..\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
       \text{ if } \forall i \in \{1 .. n\}, x_i \neq \var(r_i) \\
\end{align*}

##### Operational semantic

The full semantic is given at the figure \pref{nix-light::semantics}.

The reduction rules should be self-explained.
The only point of attention are tho two rules for the typecase, which involve a
typing judgement (and thus make the semantics somehow typing dependant).
<!---
  XXX: Should we constrain again the allowed types to prevent evaluation issues?

  The problem here is that the value is only in head normal form, while the
  type may need to explore at an arbitrary depth.
  Thus, we need either to specify complex rules for the evaluation or to
  restrict the appearing types.
--->
<!--- TODO: Find a way to express the restriction that record fields need to be
distincts --->

\input{nix-light/semantics}
