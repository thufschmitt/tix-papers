#### Grammar

This language is really similar to Nix, but makes syntactically distinct all
the elements which requires a special treatment from the typechecker.

For example, the if construct is replaced by the more general "typecase" of the
form `(x = e0 tin t) ? e1 : e2` (which evaluates to `e1` if `e0` evaluates to a
value of type `t` and to `e2` otherwise).
The general case `if e0 then e1 else e2` will be compiled to `(x = (e0 : Bool)
tin true) ? e1 : e2` (where `x` is a fresh variable), whereas particular cases
such as `if isInt x then e1 else e2` may be compiled to spcialized versions
such as `(x = x tin Int) ? e1 : e2`.
This lightens the type-system as both forms can be treated with the same rule.
However, this loosens a little bit the expressivity, as an expression such as
`let f = isInt in if f x then x else 1` won't be recognized by the compiler
(because it has no type information, so can't see that `f` is the same
predicate over types as `isInt` and thus should be treated the same way.

Nix-light's grammar is given in figures \pref{nix-light::grammar}
and \pref{nix-light::grammar::values}.
The construct `<$\hat{t}$>` (defining the types that appears in a typecase) is
a non-recursive version of `<t>` (so the typecase is in reallity more somethifg
like a "kind-case" which just checks for the head constuctor). The type
`Any$\vee \nabla$` represents an optional field (the reason for this notation
is explained in Section \ref{typing::structures::records}).

The `<>` operator defines the concatenation of records.
In what follows, we assume that this operator is commutative. As consequence,
we allow ourselves to reorder at will the terms of an expression of the form
`<expr> <> $\cdots$ <> <expr>`.
Moreover, we often write `{ x1 = e1; $\cdots$; xn = en }` as a shortcut for
`{ x1 = e1 } <> $\cdots$ <> { xn = en }`.

\begin{figure}
  \small
  \begin{lstlisting}
<expr> ::= <ident> | <constant>
  | <expr>.<expr> | <expr>.<expr> or <expr>
  | λ <pattern>.<expr> | <expr> <expr>
  | let <var-pattern> = <expr>; $\cdots{}$; <var-pattern> = <expr>; in <expr>
  | Cons (<expr>, <expr>)
  | { <ident> = <expr> } | {} | <expr> <> ... <> <expr>
  | (<ident> = <expr> $\in$ <$\hat{t}$>) ? <expr> : <expr>
  | <operator>
  | <expr>:<τ>

<constant> ::= <string> | <int> | <bool> | Nil

<operator> ::=
  | <expr> <infix-op> <expr>

<infix-op> ::= + | - | * | / | // | ++ | $\cdots$

<pattern> ::= <record-pattern> | <record-pattern>@<ident>
  | <var-pattern>

<record-pattern> ::= <record-pattern>:τ
  | { <record-pattern-field>, $\cdots$, <record-pattern-field> }
  | { <record-pattern-field>, $\cdots$, <record-pattern-field>, … }

<record-pattern-field> ::= <var-pattern> | <var-pattern> ? <constant>

<var-pattern> ::= <ident> | <ident>:<τ>

<basetype> ::= Bool | Int | String | Any | Empty

<t> ::= <constant> | <basetype>
  | <t> $\vee$ <t> | <t> $\wedge$ <t> | $\lnot$ <t>
  | <t> $\rightarrow$ <t>
  | Cons(<t>, <t>) | let <ident> = <t>; $\cdots$; <ident> = <t> in <t>
  | { <ident> = <t>; $\cdots$; <ident> = <t>; _ = <t> }

<τ> ::= <constant> | <basetype> | <t> | ?
  | <τ> $\vee$ <τ> | <τ> $\wedge$ <τ>
  | <τ> $\rightarrow$ <τ>
  | Cons(<τ>, <τ>) | let <ident> = <τ>; $\cdots$; <ident> = <τ> in <τ>
  | { <ident> = <τ>; $\cdots$; <ident> = <τ>; _ = <τ> }

<$\hat{t}$> ::= <constant> | <basetype>
  | <$\hat{t}$> $\vee$ <$\hat{t}$> | <$\hat{t}$> $\wedge$ <$\hat{t}$> | $\lnot$ <$\hat{t}$>
  | Empty $\rightarrow$ Any
  | Cons(Any, Any)
  | { <ident> = Any; $\cdots$; <ident> = Any; _ = Any$\vee \nabla$ }
  \end{lstlisting}
  \caption{Nix-light grammar for expressions\label{nix-light::grammar}}
\end{figure}

\begin{figure}
  \begin{lstlisting}
<value> ::=
  | <constant>
  | Cons(<value>, <value>)
  | { <ident> = <value>; $\cdots$; <ident> = <value>; }
  | λ<pattern>.<expr>
  \end{lstlisting}
  \caption{Nix-light grammar for values\label{nix-light::grammar::values}}
\end{figure}

#### Semantic

##### Pattern-matching

The pattern-matching in Nix-light has a rather classical semantic for a lazy
language, with the simplification that as the patterns aren't recursive, the
argument is either non-evaluated at all, either evaluated in head normal form.

\newcommand{\var}{\mathcal{V}}
If `r` is a variable pattern − hence in the forme `x` or `x:τ` where `x` is an
ident and `τ` a type − we define the variable represented by `r` (that we note
$\var(r)$) as $\var(x) = \var(x:\τ) = x$.
In what follows, `l` designs a record-pattern field (of the form `r` or `r?c`
where `c` is a constant).

For a pattern `p` and a value `v` (resp. an expression `e`), we define the
substitution generated by the matching of `v` (resp. `e`) against `p` (noted
$\sfrac{p}{v}$) as follows:

\begin{align*}
  \sfrac{x}{e}    &= x := e \\
  \sfrac{p:\τ}{e}  &= \sfrac{p}{e} \\
  \sfrac{q@x}{v}  &= x := v; \sfrac{q}{v} \\
  \sfrac{\{..\}}{\{\cdots\}} &= \varnothing\\
  \sfrac{\{\}}{\{\}} &= \varnothing \\
  \sfrac{\{ r_1, l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m\}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1, l_1, \cdots, l_m, .. \}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m, .. \}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m\}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m, .. \}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{e_1};
       \sfrac{\{ l_1, \cdots, l_m, .. \}}{\{ x_2 = e_2; \cdots; x_n = e_n; \}}
       \text{ if } x_1 = \var(r_1) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{c};
       \sfrac{\{ l_1, \cdots, l_m\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
       \text{ if } \forall i \in \{1 .. n\}, x_i \neq \var(r_i) \\
  \sfrac{\{ r_1 ? c, l_1, \cdots, l_m, ..\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
    &= \sfrac{r_1}{c};
       \sfrac{\{ l_1, \cdots, l_m, ..\}}{\{ x_1 = e_1; \cdots; x_n = e_n; \}}
       \text{ if } \forall i \in \{1 .. n\}, x_i \neq \var(r_i) \\
\end{align*}

##### Operational semantic

The full semantic is given at the figure \pref{nix-light::semantics}.

The reduction rules should be self-explained.
The only point of attention are tho two rules for the typecase, which involve a
typing judgement (and thus make the semantics somehow typing dependant).
<!---
  XXX: Should we constrain again the allowed types to prevent evaluation issues?

  The problem here is that the value is only in head normal form, while the
  type may need to explore at an arbitrary depth.
  Thus, we need either to specify complex rules for the evaluation or to
  restrict the appearing types.
--->
<!--- TODO: Find a way to express the restriction that record fields need to be
distincts --->

\input{nix-light/semantics}
